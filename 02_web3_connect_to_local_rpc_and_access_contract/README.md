# 02 Use web3 to connect to local rpc and access contract

If you look into the `dependencies` section of the `package.json` file you will noticed that `web3` is added. From now one, whenever you run `npm install` and `web3` will be installed as one of our dependencies. (you can find it under `node_moudles`)

Now it's time to include `web3` in our dapp entry file: `./app/app.js`
```js
console.log('WELCOME TO DEXON WORKSHOP');

const init = async () => {
  /**
   * Make sure that when you get here, basic UI has already been rendered.
   * Web3 bundle is large so we might want to import it asynchronounsly
   *
   * Web3 team is working on reducing the bundle size, let's see how it goes
   * https://github.com/ethereum/web3.js/pull/2000
   */
  const Web3 = await import('web3');
  console.log(Web3); // Check if we successfully imported something
};

## importing Web3

init();
```
We are loading `Web3` asynchronously

After running `npm run build:webapp` and open our dapp in the browser. We should see the `web3` object being printed in the developer console

If you have DekuSan walleted installed, it will inject a global object called `dexon`
In order for your Dapp to access user's account address, you need to:
```
/**
* Request approval to read account address from DekuSan wallet
*/
await window.dexon.enable();
```

## Accessing to DEXON

`dexon` is also a HTTP provider which allows you to communicate with RPC server over HTTP
```js
const init = async () => {
  const Web3 = await import('web3');
  let httpHandler;
  if (window.dexon) {
    await window.dexon.enable();
    /**
     * 1. DekuSan wallet injects a global variable called 'dexon'
     * 2. 'dexon' is a HTTP provider which allows you to communicate with RPC server over HTTP
     * 3. By passing the provider to web3, we are now able to interact with DEXON
     */
    httpHandler = new Web3.default(window.dexon);
    // httpHandler allows us to interact with the DEXON network
    console.log(httpHandler);
  }
};
```

We just passed in `dexon` provider to web3 and an object is returned (httpHandler).
Let's access some information from the network
```js
// Get the ID of the network which DekuSan wallet is currently connecting to
const networkID = await httpHandler.eth.net.getId();
console.log(`Network id: ${networkID}`); // 5777 for local rpc, 238 for DEXON testnet
```

- Network ID is important becasue that's how dapp knows if the user is using testnet or mainnet
- We also need network id to connect to correct websocket provider. We'll talk about it later.
- All the utils to interat with the network is under `eth`. Web3 is maintained by Ethereum foundation so they called it `eth` but it will work with `DEXON`'s network as well

## Contract Interaction

Now it's time to interact with our smart contract! Remember the artifacts built by `dexon-truffle`? It has something that we need.
- If `./build` is not found under project root, we can re-build it by `npm run compile`
- Make sure local test rpc is running by `npm run rpc`
- Deploy our smart contract to local test network by `npm run migrate:development`

If you are not familiar with the above steps, please visit `01_build_and_deploy_contract_to_local_ganache`

Let's get back to our `./app/app.js`. Information we need of the `Hello.sol` smart contract is in `./build/contracts/Hello.json` so it's time to import it

```js
/**
  * import the build artifacts generated by Truffle
  * abi and networks is what we care the most
  */
const contractInfo = (await import('../build/contracts/Hello.json')).default;
console.log('Build artifacts by truffle:', contractInfo);
const { abi, networks } = contractInfo;
console.log('contract ABI', abi);
console.log('Netowkr information', networks);

// Iterate all network id and the address of the deployed contract on that network
Object.keys(networks).forEach(
  id => console.log(`Network ${id}: Contract is deployed to: ${networks[id].address}`)
);
```

We should use the contract address from our current network
```js
// Choose the contract address from our current network
const address = networks[networkID].address;
console.log(`We are using ${address} on network ${networkID}`);
```

By passing `abi` and `address` to `httpHandler.eth.Contract`, we got an instance which we can use to interact with smart contract.
  - `eth` provides utils
```js
// In order to interact with smart contract, we need to initial a "we3.eth.Contract" instance
const helloContract = new httpHandler.eth.Contract(abi, address);
```

There is a method call `get` in our `Hello.sol` smart contract. Let's access it.
```js
// Let's call the "get" function of our Hello.sol smart contract
const val = await helloContract.methods.get().call();
console.log('Get: ', val);
```

It works! Now we know how to read from contract. Let's bind the function to the "get" button
```js
    /**
      Let's bind an onclick function to the "get" button
      When we click that button, we call the contract's get function
     */
    const getButton = document.getElementById('get');
    getButton.onclick = async () => {
      // use 'call()' if the function only reads contract state
      const ret = await helloContract.methods.get().call();
      alert(ret);
    };
```

- `get` function reads from contract state only. It doesn't change contract state that's why no transaction is needed.

Let's call `update` which changes contract state
```js
// Get user account.
const accountList = await httpHandler.eth.getAccounts();
const myAccount = accountList[0];
console.log('account', myAccount);

/**
  Let's bind an onclick function to the "update" button
  When we click that button, we send transction
  */
const updateButton = document.getElementById('update');
updateButton.onclick = async () => {
  // use 'send()' if the function needs a transaction 
  const ret = await helloContract.methods.update().send({
    from: myAccount,
  });
  console.log('Update result', ret);
};
```

- When we click the update button, a transaction will be sent by DekuSan
- With the speed of DEXON, transaciton will be confirmed shortly
- We can click on "update" button again to see the latest result
